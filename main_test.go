// Package main_test provides comprehensive benchmarks and tests for the
// advanced genpass implementation showcasing modern Go testing patterns.
//
//go:build go1.25
// +build go1.25

package main

import (
	"context"
	"fmt"
	"runtime"
	"slices"
	"strings"
	"sync"
	"testing"
	"time"
)

// Test suite for advanced generator functionality

func TestGeneratorType(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected GeneratorType
		wantErr  bool
	}{
		{"hyphenated", "hyphenated", GeneratorHyphenated, false},
		{"hyphenated_short", "h", GeneratorHyphenated, false},
		{"compact", "compact", GeneratorCompact, false},
		{"compact_short", "c", GeneratorCompact, false},
		{"invalid", "invalid", 0, true},
		{"empty", "", 0, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ParseGeneratorType(tt.input)
			if tt.wantErr && err == nil {
				t.Errorf("ParseGeneratorType(%q) expected error, got nil", tt.input)
			}
			if !tt.wantErr && err != nil {
				t.Errorf("ParseGeneratorType(%q) unexpected error: %v", tt.input, err)
			}
			if !tt.wantErr && result != tt.expected {
				t.Errorf("ParseGeneratorType(%q) = %v, want %v", tt.input, result, tt.expected)
			}
		})
	}
}

func TestCharacterSet(t *testing.T) {
	t.Run("basic_functionality", func(t *testing.T) {
		cs := NewCharacterSet("abc123")

		if cs.Len() != 6 {
			t.Errorf("CharacterSet.Len() = %d, want 6", cs.Len())
		}

		// Test character access
		char := cs.At(0)
		if !slices.Contains([]byte("abc123"), char) {
			t.Errorf("CharacterSet.At(0) = %c, not in expected set", char)
		}
	})

	t.Run("deduplication", func(t *testing.T) {
		cs := NewCharacterSet("aabbcc")
		if cs.Len() != 3 {
			t.Errorf("CharacterSet with duplicates, Len() = %d, want 3", cs.Len())
		}
	})

	t.Run("power_of_2_optimization", func(t *testing.T) {
		// Test with power-of-2 character set
		cs := NewCharacterSet("abcd")
		if cs.mask == 0 {
			t.Error("Power-of-2 character set should have optimization mask")
		}

		// Test with non-power-of-2 character set
		cs2 := NewCharacterSet("abcde")
		if cs2.mask != 0 {
			t.Error("Non-power-of-2 character set should not have optimization mask")
		}
	})
}

func TestGeneratorConfig(t *testing.T) {
	tests := []struct {
		name    string
		config  *GeneratorConfig
		wantErr bool
	}{
		{
			name: "valid_config",
			config: &GeneratorConfig{
				Type:    GeneratorCompact,
				Length:  16,
				Count:   1,
				Charset: NewCharacterSet(alphanumericChars),
				Workers: 1,
			},
			wantErr: false,
		},
		{
			name: "invalid_length",
			config: &GeneratorConfig{
				Type:    GeneratorCompact,
				Length:  0,
				Count:   1,
				Charset: NewCharacterSet(alphanumericChars),
				Workers: 1,
			},
			wantErr: true,
		},
		{
			name: "invalid_count",
			config: &GeneratorConfig{
				Type:    GeneratorCompact,
				Length:  16,
				Count:   0,
				Charset: NewCharacterSet(alphanumericChars),
				Workers: 1,
			},
			wantErr: true,
		},
		{
			name: "empty_charset",
			config: &GeneratorConfig{
				Type:    GeneratorCompact,
				Length:  16,
				Count:   1,
				Charset: NewCharacterSet(""),
				Workers: 1,
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.config.Validate()
			if tt.wantErr && err == nil {
				t.Errorf("GeneratorConfig.Validate() expected error, got nil")
			}
			if !tt.wantErr && err != nil {
				t.Errorf("GeneratorConfig.Validate() unexpected error: %v", err)
			}
		})
	}
}

func TestBufferPool(t *testing.T) {
	pool := NewBufferPool(1024)

	// Test buffer allocation and return
	buf1 := pool.Get()
	if buf1 == nil {
		t.Fatal("BufferPool.Get() returned nil")
	}

	buf1.Write([]byte("test"))
	if buf1.String() != "test" {
		t.Errorf("Buffer content = %q, want %q", buf1.String(), "test")
	}

	pool.Put(buf1)

	// Get another buffer - should be the same one, reset
	buf2 := pool.Get()
	if buf2.String() != "" {
		t.Errorf("Reused buffer should be empty, got %q", buf2.String())
	}

	pool.Put(buf2)
}

func TestEntropySource(t *testing.T) {
	es := NewEntropySource()

	t.Run("generate_bytes", func(t *testing.T) {
		bytes, err := es.GenerateBytes(32)
		if err != nil {
			t.Fatalf("EntropySource.GenerateBytes() error: %v", err)
		}

		if len(bytes) != 32 {
			t.Errorf("Generated bytes length = %d, want 32", len(bytes))
		}

		// Check that bytes are not all zeros (extremely unlikely)
		allZeros := true
		for _, b := range bytes {
			if b != 0 {
				allZeros = false
				break
			}
		}
		if allZeros {
			t.Error("Generated bytes are all zeros - extremely unlikely")
		}
	})

	t.Run("generate_uint64", func(t *testing.T) {
		val, err := es.GenerateUint64()
		if err != nil {
			t.Fatalf("EntropySource.GenerateUint64() error: %v", err)
		}

		// Just ensure we got a value - randomness testing is complex
		_ = val
	})

	t.Run("health_check", func(t *testing.T) {
		if !es.Health() {
			t.Error("EntropySource should be healthy")
		}
	})

	t.Run("stats", func(t *testing.T) {
		generated, errors := es.Stats()
		if generated == 0 {
			t.Error("Stats should show generated bytes > 0")
		}
		if errors > generated {
			t.Error("Errors should not exceed generated count")
		}
	})
}

func TestCryptoGenerator(t *testing.T) {
	gen := NewCryptoGenerator(4)
	ctx := context.Background()

	config := &GeneratorConfig{
		Type:         GeneratorCompact,
		Length:       16,
		Count:        1,
		Charset:      NewCharacterSet(alphanumericChars),
		Parallel:     false,
		Workers:      1,
		ConstantTime: true,
	}

	t.Run("single_generation", func(t *testing.T) {
		result, err := gen.Generate(ctx, config)
		if err != nil {
			t.Fatalf("CryptoGenerator.Generate() error: %v", err)
		}

		if len(result) != config.Length {
			t.Errorf("Generated string length = %d, want %d", len(result), config.Length)
		}

		// Verify all characters are from charset
		for _, char := range result {
			charset := config.Charset
			valid := false
			for i := 0; i < charset.Len(); i++ {
				if byte(char) == charset.chars[i] {
					valid = true
					break
				}
			}
			if !valid {
				t.Errorf("Generated string contains invalid char: %c", char)
			}
		}
	})

	t.Run("batch_generation", func(t *testing.T) {
		config.Count = 5
		results, err := gen.GenerateBatch(ctx, config)
		if err != nil {
			t.Fatalf("CryptoGenerator.GenerateBatch() error: %v", err)
		}

		if len(results) != config.Count {
			t.Errorf("Generated batch size = %d, want %d", len(results), config.Count)
		}

		// Verify uniqueness (highly probable for crypto random)
		unique := make(map[string]bool)
		for _, result := range results {
			if unique[result] {
				t.Errorf("Duplicate string in batch: %s", result)
			}
			unique[result] = true
		}
	})

	t.Run("parallel_generation", func(t *testing.T) {
		config.Count = 10
		config.Parallel = true
		config.Workers = 4

		results, err := gen.GenerateBatch(ctx, config)
		if err != nil {
			t.Fatalf("Parallel generation error: %v", err)
		}

		if len(results) != config.Count {
			t.Errorf("Parallel batch size = %d, want %d", len(results), config.Count)
		}
	})

	t.Run("stream_generation", func(t *testing.T) {
		config.Count = 3
		results := make([]string, 0, config.Count)

		for result, err := range gen.GenerateStream(ctx, config) {
			if err != nil {
				t.Fatalf("Stream generation error: %v", err)
			}
			results = append(results, result)
		}

		if len(results) != config.Count {
			t.Errorf("Stream results count = %d, want %d", len(results), config.Count)
		}
	})

	t.Run("context_cancellation", func(t *testing.T) {
		ctx, cancel := context.WithCancel(context.Background())
		cancel() // Cancel immediately

		_, err := gen.Generate(ctx, config)
		if err == nil || err != context.Canceled {
			t.Errorf("Expected context.Canceled, got: %v", err)
		}
	})
}

func TestHyphenatedGeneration(t *testing.T) {
	gen := NewCryptoGenerator(4)
	ctx := context.Background()

	config := &GeneratorConfig{
		Type:    GeneratorHyphenated,
		Length:  18, // Set a valid length
		Count:   1,
		Charset: NewCharacterSet(alphanumericChars),
		Workers: 1,
	}

	result, err := gen.Generate(ctx, config)
	if err != nil {
		t.Fatalf("Hyphenated generation error: %v", err)
	}

	parts := strings.Split(result, "-")
	if len(parts) != 3 {
		t.Errorf("Hyphenated string parts = %d, want 3", len(parts))
	}

	for i, part := range parts {
		if len(part) != 6 {
			t.Errorf("Part %d length = %d, want 6", i, len(part))
		}
	}
}

// Benchmark suite using modern Go benchmarking patterns

func BenchmarkCharacterSet(b *testing.B) {
	cs := NewCharacterSet(alphanumericChars)

	b.Run("at_power_of_2", func(b *testing.B) {
		cs := NewCharacterSet("abcdefghijklmnop") // 16 chars = 2^4
		b.ResetTimer()

		for i := 0; i < b.N; i++ {
			cs.At(uint64(i))
		}
	})

	b.Run("at_non_power_of_2", func(b *testing.B) {
		b.ResetTimer()

		for i := 0; i < b.N; i++ {
			cs.At(uint64(i))
		}
	})
}

func BenchmarkBufferPool(b *testing.B) {
	pool := NewBufferPool(1024)

	b.Run("get_put", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			buf := pool.Get()
			buf.Write([]byte("test"))
			pool.Put(buf)
		}
	})
}

func BenchmarkEntropySource(b *testing.B) {
	es := NewEntropySource()

	b.Run("generate_bytes_32", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, err := es.GenerateBytes(32)
			if err != nil {
				b.Fatal(err)
			}
		}
	})

	b.Run("generate_uint64", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, err := es.GenerateUint64()
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func BenchmarkCryptoGenerator(b *testing.B) {
	gen := NewCryptoGenerator(runtime.NumCPU())
	ctx := context.Background()

	configs := map[string]*GeneratorConfig{
		"compact_16": {
			Type:    GeneratorCompact,
			Length:  16,
			Count:   1,
			Charset: NewCharacterSet(alphanumericChars),
			Workers: 1,
		},
		"compact_64": {
			Type:    GeneratorCompact,
			Length:  64,
			Count:   1,
			Charset: NewCharacterSet(alphanumericChars),
			Workers: 1,
		},
		"hyphenated": {
			Type:    GeneratorHyphenated,
			Length:  18, // Valid length
			Count:   1,
			Charset: NewCharacterSet(alphanumericChars),
			Workers: 1,
		},
	}

	for name, config := range configs {
		b.Run("single_"+name, func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				_, err := gen.Generate(ctx, config)
				if err != nil {
					b.Fatal(err)
				}
			}
		})
	}

	b.Run("parallel_batch", func(b *testing.B) {
		config := &GeneratorConfig{
			Type:     GeneratorCompact,
			Length:   32,
			Count:    100,
			Charset:  NewCharacterSet(alphanumericChars),
			Parallel: true,
			Workers:  runtime.NumCPU(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			_, err := gen.GenerateBatch(ctx, config)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

// Concurrent stress test
func TestConcurrentStress(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping stress test in short mode")
	}

	gen := NewCryptoGenerator(runtime.NumCPU() * 2)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	config := &GeneratorConfig{
		Type:     GeneratorCompact,
		Length:   32,
		Count:    1,
		Charset:  NewCharacterSet(alphanumericChars),
		Parallel: true,
		Workers:  runtime.NumCPU(),
	}

	const numGoroutines = 50
	const generationsPerGoroutine = 100

	var wg sync.WaitGroup
	results := sync.Map{}
	errors := make(chan error, numGoroutines*generationsPerGoroutine)

	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			for j := 0; j < generationsPerGoroutine; j++ {
				result, err := gen.Generate(ctx, config)
				if err != nil {
					errors <- fmt.Errorf("goroutine %d, iteration %d: %w", id, j, err)
					return
				}

				// Check for duplicates (should be extremely rare)
				if _, exists := results.LoadOrStore(result, true); exists {
					errors <- fmt.Errorf("duplicate generated: %s", result)
					return
				}
			}
		}(i)
	}

	wg.Wait()
	close(errors)

	// Check for errors
	for err := range errors {
		t.Error(err)
	}

	// Count unique results
	count := 0
	results.Range(func(key, value interface{}) bool {
		count++
		return true
	})

	expected := numGoroutines * generationsPerGoroutine
	if count != expected {
		t.Errorf("Generated %d unique strings, expected %d", count, expected)
	}

	// Print stats
	generated, genErrors, avgDuration := gen.Stats()
	t.Logf("Stress test stats: %d generated, %d errors, avg duration: %v",
		generated, genErrors, avgDuration)
}

// Example usage tests showing the new API
func ExampleCryptoGenerator_Generate() {
	gen := NewCryptoGenerator(4)
	ctx := context.Background()

	config := &GeneratorConfig{
		Type:    GeneratorCompact,
		Length:  16,
		Count:   1,
		Charset: NewCharacterSet(alphanumericChars),
		Workers: 1,
	}

	result, err := gen.Generate(ctx, config)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Generated: %s\n", result)
	fmt.Printf("Length: %d\n", len(result))
	// Output will vary due to randomness, but format is:
	// Generated: [16 character alphanumeric string]
	// Length: 16
}

func ExampleCryptoGenerator_GenerateStream() {
	gen := NewCryptoGenerator(4)
	ctx := context.Background()

	config := &GeneratorConfig{
		Type:    GeneratorHyphenated,
		Count:   3,
		Charset: NewCharacterSet(alphanumericChars),
		Workers: 1,
	}

	for result, err := range gen.GenerateStream(ctx, config) {
		if err != nil {
			panic(err)
		}
		fmt.Printf("Generated: %s\n", result)
	}
	// Output will vary due to randomness, but format is:
	// Generated: [6chars]-[6chars]-[6chars]
	// Generated: [6chars]-[6chars]-[6chars]
	// Generated: [6chars]-[6chars]-[6chars]
}
